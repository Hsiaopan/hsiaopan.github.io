<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hsiaopan.github.io</id>
    <title>Panalyz</title>
    <updated>2020-06-01T13:39:35.090Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hsiaopan.github.io"/>
    <link rel="self" href="https://hsiaopan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://hsiaopan.github.io/images/avatar.png</logo>
    <icon>https://hsiaopan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Panalyz</rights>
    <entry>
        <title type="html"><![CDATA[Python实现10大排序算法]]></title>
        <id>https://hsiaopan.github.io/post/Algorithm_of_Sorting_by_Python/</id>
        <link href="https://hsiaopan.github.io/post/Algorithm_of_Sorting_by_Python/">
        </link>
        <updated>2020-06-01T12:44:05.000Z</updated>
        <summary type="html"><![CDATA[<p>Python实现10种排序算法。通过Java版改写，可能有句法不那么Python的问题。另外，第10个还没写出来，有空再补上。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Python实现10种排序算法。通过Java版改写，可能有句法不那么Python的问题。另外，第10个还没写出来，有空再补上。</p>
<!-- more -->
<ul>
<li>
<h3 id="bubble-sort-冒泡排序">Bubble Sort 冒泡排序</h3>
</li>
</ul>
<blockquote>
<p>比较相邻的元素，如果第一个比第二个大，就交换他们。对每一对相邻元素做相同的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个重复以上步骤，直到排序完成.</p>
</blockquote>
<pre><code>def bubble_sort(arr):
    for i in range(len(arr) - 1):
        for j in range(len(arr) - i - 1):
            if arr[j] &gt; arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    print(arr)
    return

list1 = [1, 23, 43, 2, 3, 54, 6, 34, 81, 99, 342, 3, 4452, 344, 234, 44, 55, 67, 57, 24, 723]
bubble_sort(list1)
</code></pre>
<ul>
<li>
<h3 id="selection-sort-选择排序">Selection Sort 选择排序</h3>
</li>
</ul>
<blockquote>
<p>首先从未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后从剩余未排序元素中继续寻 找最小（大）元素，移动到已排序末尾。以此类推，直到所有元素均排序完毕</p>
</blockquote>
<pre><code>def selection_sort(arr):
    for i in range(len(arr) - 1):
        min_index = i
        for j in range(i + 1, len(arr)):
            if arr[j] &lt; arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

list1 = [1, 23, 43, 2, 3, 54, 6, 34, 81, 99, 342, 3, 4452, 344, 234, 44, 55, 67, 57, 24, 723]
print(selection_sort(list1))
</code></pre>
<ul>
<li>
<h3 id="insertion-sort-插入排序">Insertion Sort 插入排序</h3>
</li>
</ul>
<blockquote>
<p>通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
</blockquote>
<pre><code>def insertion_sort(arr):
    for i in range(1, len(arr)):
        previous = i - 1
        current = arr[i]
        while previous &gt;= 0 and arr[previous] &gt; current:
            arr[previous + 1] = arr[previous]
            previous -= 1
        arr[previous+1] = current
    return arr

list1 = [1, 23, 43, 2, 3, 54, 6, 34, 81, 99, 342, 3, 4452, 344, 234, 44, 55, 67, 57,24, 723]
print(insertion_sort(list1))
</code></pre>
<ul>
<li>
<h3 id="shell-sort-希尔排序">Shell Sort 希尔排序</h3>
</li>
</ul>
<blockquote>
<p>简单插入排序的改进版，它与插入排序不同之处在于，他会优先比较距离较远的元素希尔排序又叫“缩小增量排序”</p>
</blockquote>
<pre><code>def shell_sort(arr):
    gap = len(arr) // 2
    while gap &gt; 0:
        for i in range(gap, len(arr)):
            while i - gap &gt;= 0 and arr[i] &lt; arr[i - gap]:
                arr[i], arr[i-gap] = arr[i - gap], arr[i]
                i -= gap
        gap = gap // 2
    return arr

list1 = [1, 23, 43, 2, 54, 6, 34, 81, 99, 342, 3, 4452, 344, 234, 44, 55, 67, 57, 24, 723]
print(shell_sort(list1))
</code></pre>
<ul>
<li>
<h3 id="merge-sort-归并排序">Merge Sort 归并排序</h3>
</li>
</ul>
<blockquote>
<p>将已有序的子序列合并，得到完整有序的序列；即先使每个子序列有序，再使子序列段间有序</p>
</blockquote>
<pre><code>def merge_sort(arr):
    if len(arr) &lt; 2:
        return arr
    middle = len(arr) // 2
    left = merge_sort(arr[:middle])
    right = merge_sort(arr[middle:])
    return merge(left, right)

def merge(a, b):
    aux = []
    while len(a) &gt; 0 and len(b) &gt; 0:
        if a[0] &lt;= b[0]:
            aux.append(a.pop(0))
        else:
            aux.append(b.pop(0))
    else:
        if len(a) == 0:
            aux += b
        else:
            aux += a
    return aux


list1 = [1, 23, 43, 2, 54, 6, 34, 81, 99, 342, 3, 4452, 344, 234, 44, 55, 67, 57, 24, 723]
print(merge_sort(list1))
</code></pre>
<ul>
<li>
<h3 id="quick-sort-快速排序">Quick Sort 快速排序</h3>
</li>
</ul>
<blockquote>
<p>在序列中选择一个基准点，然后分别从序列的两段扫描，设两个指示标志。从后半部分开始，如果有元素 比该基准点小，就交换两个指示标志位置的值，然后从前半部分开始扫描，发现有元素大于基准点的值，就交换两个指示标志位置的值，如此往复循环，直到俩指示标志的前者与后者相当或前者大于后者，交换 位置，一次排序完成了。以后采用递归的方式，分别对前半部分和后半部分排序</p>
</blockquote>
<pre><code>def quick_sort(arr):
    return q_sort(arr, 0, len(arr) - 1)

def q_sort(arr, lo, hi):
    if lo &lt; hi:
        pivot = partition(arr, lo, hi)
        q_sort(arr, lo, pivot - 1)
        q_sort(arr, pivot + 1, hi)
    return arr

def partition(arr, lo, hi):
    pivot_value = arr[hi]
    i = lo - 1
    for j in range(lo, hi):
        if arr[j] &lt;= pivot_value:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[hi] = arr[hi], arr[i + 1]
    return i + 1

list1 = [1, 23, 43, 2, 54, 6, 34, 81, 99, 342, 3, 4452, 344, 234, 44, 55, 67, 57, 24, 723]
print(quick_sort(list1))
</code></pre>
<pre><code>def quick_sort(arr, lo, hi):
    if lo &gt; hi:
        return
    stack = []
    stack.append(lo)
    stack.append(hi)
    while stack:
        lo = stack.pop(0)
        hi = stack.pop(0)
        if hi - lo &lt;= 0:
            continue
        pivot = arr[hi]
        i = lo - 1
        for j in range(lo, hi):
            if arr[j] &lt;= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
        arr[i + 1], arr[hi] = arr[hi], arr[i + 1]
        stack.extend([lo, i, i + 2, hi])
</code></pre>
<ul>
<li>
<h3 id="heap-sort-堆排序">Heap Sort 堆排序</h3>
</li>
</ul>
<blockquote>
<p>堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。<br>
将初始待排序关键字序列(R1,R2,R3,...Rn)构成一顶堆，此堆为初始的无序区：将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区（R1,R2,R3,...Rn-1）和新的有序区，且满足R[1,2,3,...,n-1] &lt;= R[n]；由于交换后的新的堆顶R[1]可能违反堆的性质，因为需要对当前无序区（R1,R2,R3,...,Rn-1）调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区（R1,R2,R3,...,Rn-2）和新的有序区（Rn-1,Rn）<br>
不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成</p>
</blockquote>
<pre><code>def heapify(arr, i, k):
    # 构建堆的规则
    j = 2 * i
    while j &lt;= k:
        if j &lt; k and arr[j] &lt; arr[j + 1]:
            j += 1
        if arr[i] &gt;= arr[j]:
            break
        arr[i], arr[j] = arr[j], arr[i]
        i = j
        j *= 2

def heap_sort(arr):
    # 从最后一个有子节点的节点开始构建堆
    last = len(arr) // 2 - 1
    for i in range(last, -1, -1):
        heapify(arr, i, len(arr) - 1)

    # 将最大的数放在堆的最后一个位置，并将剩余部分重新构建堆
    for k in range(len(arr) - 1, 0, -1):
        arr[0], arr[k] = arr[k], arr[0]
        heapify(arr, 0, k - 1)

if __name__ == &quot;__main__&quot;:
    arr = [1, 23, 43, 2, 54, 6, 34, 81, 99, 342, 3, 4452, 344, 234, 44, 55, 67, 57, 24, 723]
    heap_sort(arr)
    print(arr)

list1 = [1, 23, 43, 2, 54, 6, 34, 81, 99, 342, 3, 4452, 344, 234, 44, 55, 67, 57, 24, 723]
</code></pre>
<ul>
<li>
<h3 id="counting-sort-计数排序">Counting Sort 计数排序</h3>
</li>
</ul>
<blockquote>
<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据 值转化为键存储在额外开辟的数组空间中。<br>
作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数，找出待排序的数组中最大和最小的元素；统计数组中每个值为i的元素出现的个数，存入数组C的第i项；对所有的计数累加，反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p>
</blockquote>
<pre><code>def counting_sort(arr, largest):
    bucket = [0]*(largest + 1)
        sorted_index = 0

    for i in range(len(arr)):
        bucket[arr[i]] = arr.count(arr[i])

    for j in range(len(bucket)):
        while bucket[j] &gt; 0:
            arr[sorted_index] = j
            sorted_index += 1
            bucket[j] -= 1
   return arr

list1 = [1, 23, 43, 2, 24, 54, 6, 34, 81, 99, 342, 3, 4452, 344, 234, 44, 55, 67, 57, 24, 723]
print(counting_sort(list1, 4452))
</code></pre>
<ul>
<li>
<h3 id="bucket-sort-桶排序">Bucket Sort 桶排序</h3>
</li>
</ul>
<blockquote>
<p>桶排序是计数排序的升级版。它利用函数的映射关系，高效与否的关键在于这个映射函数的确定，假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶分别排序。每个桶里的排序，有可能再使用比的排序算法，或是以递归方式继续使用桶排序</p>
</blockquote>
<ul>
<li>设置一个定量的数组当做空桶</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里</li>
<li>对每个不是空的桶进行排序</li>
<li>从不是空的桶里把排好序的数据拼接起来</li>
</ul>
<pre><code>def bucket_sort(arr, bucket_size):
    if len(arr) == 0:
        return arr

    min_value = arr[0]
    max_value = arr[0]
    for i in range(len(arr)):
        if arr[i] &lt; min_value:
            min_value = arr[i]
        if arr[i] &gt; max_value:
            max_value = arr[i]

    # bucket_size = 5
    bucket_count = (max_value - min_value) // bucket_size + 1
    buckets = [[]*i for i in range(bucket_count)]

    for i in range(len(arr)):
        buckets[(arr[i] - min_value) // bucket_size].append(arr[i])
    # print(buckets)

    arr = []
    for i in range(len(buckets)):
        insertion_sort(buckets[i])
        for j in range(len(buckets[i])):
            arr.append(buckets[i][j])

    # print(buckets)

    return arr


list1 = [1, 23, 43, 2, 24, 54, 6, 34, 81, 99, 342, 3, 4452, 344, 234, 44, 55, 67, 57, 24, 723]
print(bucket_sort(list1, 50))
</code></pre>
<ul>
<li>
<h3 id="tbc">TBC</h3>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Excel数据分析——以招聘数据为例]]></title>
        <id>https://hsiaopan.github.io/post/Data_Analysis_of_Job_Information_by_Excel/</id>
        <link href="https://hsiaopan.github.io/post/Data_Analysis_of_Job_Information_by_Excel/">
        </link>
        <updated>2020-05-10T14:04:45.000Z</updated>
        <summary type="html"><![CDATA[<p>以某招聘网站的数据分析师招聘信息为样本数据，选取一个角度进行分析。熟悉使用Excel进行数据分析的基本步骤和常见操作</p>
]]></summary>
        <content type="html"><![CDATA[<p>以某招聘网站的数据分析师招聘信息为样本数据，选取一个角度进行分析。熟悉使用Excel进行数据分析的基本步骤和常见操作</p>
<!-- more -->
<h2 id="前言">前言</h2>
<hr>
<p><em>明确总体目的</em>：<br>
以某招聘网站的数据分析师岗位的招聘信息为数据基础，探索不同城市数据分析师需求特点以及薪资情况。</p>
<h2 id="分析前准备">分析前准备</h2>
<p>在做数据分析之前，需要对整体数据做一个初步认识，各列数据有什么意义，哪些列是分析必用，哪些是可以暂时有用，哪些是明确无用的。<br>
<img src="https://hsiaopan.github.io/post-images/1591000582031.jpg" alt="" loading="lazy"></p>
<ul>
<li><code>城市</code>：因为需要分析不同城市的情况，还会做出对比，因此 <code>城市</code> 是分析必用的</li>
<li><code>职位ID</code>：在数据无重复情况下，职位ID应当是每个招聘岗位的唯一ID，是必须用到的</li>
<li><code>职位名称</code>：此表中职位名称并没有一个统一，还有些非数据分析师岗位名称，后面处理数据时需要用到</li>
<li><code>薪水</code>：必用的</li>
<li><code>工作年限要求</code>：必用的<br>
以上这些列是此次分析不用用到的列数据。<br>
暂时用不到的列，诸如 <code>公司ID</code> 、<code>公司大小</code> 、<code>职能所属</code> 、<code>教育要求</code> 、<code>公司所属领域</code> ，此次不做分析（如从其他角度分析，则依然有用）<br>
明确用不到的列，如 <code>公司全名</code> 、<code>公司简称</code> 、<code>公司所在商区</code> 、<code>职位福利</code></li>
</ul>
<p>此外，清楚各列数据的数据类型，如字符串、数值等</p>
<h2 id="明确分析问题">明确分析问题</h2>
<ul>
<li>不同城市对数据分析师的需求量比较</li>
<li>数据分析师在不同城市的平均薪资对比</li>
<li>工作年限对薪资影响</li>
<li>不同工作年限的需求量比较</li>
</ul>
<h2 id="数据处理">数据处理</h2>
<p>数据清洗工作是进行数据分析前所必须完成的工作，数据的整洁直接影响数据分析结果的呈现。</p>
<h3 id="1理解数据选择重点分析对象">1.理解数据，选择重点分析对象</h3>
<p>在分析前准备中提到，原始数据中包含很多列数据，有些数据不是重点分析对象，可将其隐藏。<br>
<img src="https://hsiaopan.github.io/post-images/1590989122693.jpg" alt="" loading="lazy"><br>
<em>隐藏前</em><br>
<img src="https://hsiaopan.github.io/post-images/1591002416200.jpg" alt="" loading="lazy"><br>
<em>隐藏后</em></p>
<h3 id="2删除重复值">2.删除重复值</h3>
<p>本数据中一个 <code>职位ID</code> 对应一个<strong>职位</strong>，检查 <code>职位ID</code> 列是否有重复，如果有则将重复值删除<br>
具体操作：</p>
<ul>
<li><code>条件格式</code>&gt;<code>突出显示单元格规则</code>&gt;<code>重复值</code><br>
<img src="https://hsiaopan.github.io/post-images/1590989050028.jpg" alt="" loading="lazy"></li>
<li><code>数据</code>&gt;<code>删除重复值</code>&gt;<code>选择列</code>，选择 <code>职位ID</code> 列<br>
<img src="https://hsiaopan.github.io/post-images/1590990563550.jpg" alt="" loading="lazy"></li>
</ul>
<h3 id="3处理缺失值">3.处理缺失值</h3>
<p>检查每一列的值是否一致，查看是否存在缺失值<br>
选中所在列：<code>开始</code>&gt;<code>查找与选择</code>&gt;<code>定位条件</code>&gt;<code>空值</code>&gt;输入值</p>
<blockquote>
<p>缺省值处理的常用方法：</p>
<ul>
<li>通过人工手动补全</li>
<li>删除缺省值</li>
<li>用平均值替代缺省值</li>
<li>用统计模型计算出的值去代替缺省值</li>
</ul>
</blockquote>
<h3 id="4一致化处理">4.一致化处理</h3>
<p>把所有的数据处理成容易使用公式或数据透视表的形式</p>
<p>数据表中 <code>公司所属领域</code> 这一列，有些公司从属于一个行业，有些公司则从属于两个行业，此时需要将这两个行业分割开来。使用 <code>分列</code>。<br>
<img src="https://hsiaopan.github.io/post-images/1590990673966.jpg" alt="" loading="lazy"><br>
<img src="https://hsiaopan.github.io/post-images/1590990692337.jpg" alt="" loading="lazy"></p>
<p>数据表中 <code>薪水</code> 这一列是以区间方式表示的，把最低薪水和最高薪水分隔开来以便使用图表查看薪水情况<br>
此处涉及到对表格字符串截取的操作，通常使用函数<strong>LEFT/RIGHT/MID</strong>截取，用函数<strong>FIND</strong>和<strong>LEN</strong>进行定位。<br>
观察发现 <code>薪水</code>列中数据有出现大小写<strong>K/k</strong>混用情况，先将他们统一替换成小写<strong>k</strong><br>
<img src="https://hsiaopan.github.io/post-images/1590990737454.jpg" alt="" loading="lazy"></p>
<p>插入两列，分别提取最低薪水和最高薪水。<br>
<img src="https://hsiaopan.github.io/post-images/1590990780347.jpg" alt="" loading="lazy"><br>
因 <code>薪水</code> 中一些单元格内是“xx以上”或“xx以下”，不能直接套用复合函数，我们可以先对单元格进行判断，不是以 “<strong>k</strong>”结束的单元格，最高薪水暂定与最低薪水相同。<br>
<img src="https://hsiaopan.github.io/post-images/1590990794957.jpg" alt="" loading="lazy"></p>
<p>经过单元格计算得到的最高薪水和最低薪水是文本型数据，无法正常按照数值进行排序，需要将结果复制出来，新建列表。<br>
流程如下：<br>
<code>开始</code>&gt;<code>选择性粘贴</code>&gt;勾选<code>值</code>和<code>添加</code>，然后补全列表名<br>
<img src="https://hsiaopan.github.io/post-images/1590991790591.jpg" alt="" loading="lazy"></p>
<p>可实现正常排序<br>
<img src="https://hsiaopan.github.io/post-images/1590991804223.jpg" alt="" loading="lazy"></p>
<p><code>职位名称</code> 列内职位名称种类非常多，有些甚至不是数据分析师，需要先初步判断下那些需要留存。<br>
<img src="https://hsiaopan.github.io/post-images/1590992307204.jpg" alt="" loading="lazy"><br>
可以提取含有“数据分析”、“分析师”、“数据科学”、“数据运营”的行。<br>
新建一列表名“数据分析师”，使用函数<strong>IF/COUNT/FIND</strong>，如果单元格中含有“分析”、“数据科学”、“数据运营”，则返回“是”<br>
<img src="https://hsiaopan.github.io/post-images/1590992419601.jpg" alt="" loading="lazy"></p>
<p>筛选 <code>数据分析师</code> 列中为“<strong>是</strong>”的所有行，，完成对数据分析师列数据的统一。<br>
复制整个表数据作为最终数据<br>
<img src="https://hsiaopan.github.io/post-images/1590992035301.jpg" alt="" loading="lazy"></p>
<h2 id="构建模型">构建模型</h2>
<p>数据经过清洗之后，需要构建一套模型，以实现分析这些数据的目的。<br>
如前面提到，想要知道不同城市的数据分析师招聘岗位对不同工作年限的人是怎样的需求情况，利用数据透视功能，得到以下数据透视表：<br>
<img src="https://hsiaopan.github.io/post-images/1590992146789.jpg" alt="" loading="lazy"><br>
<img src="https://hsiaopan.github.io/post-images/1590992153034.jpg" alt="" loading="lazy"><br>
想要获取不同工作年限的岗位提供的薪资水平情况，可得到以下数据透视表：<br>
<img src="https://hsiaopan.github.io/post-images/1590993620998.jpg" alt="" loading="lazy"><br>
想要获取不同城市的平均薪资水平，可得以下数据透视表：<br>
<img src="https://hsiaopan.github.io/post-images/1590993667780.jpg" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://hsiaopan.github.io/post-images/1590999101248.jpg" alt="" loading="lazy"></figure>
<p>利用“<strong>描述性统计</strong>”功能可以堆平均薪资进行分析，<br>
<code>数据</code>&gt;<code>数据分析</code>&gt;<code>描述统计</code><br>
<img src="https://hsiaopan.github.io/post-images/1590993915177.jpg" alt="" loading="lazy"><br>
描述性统计结果：<br>
<img src="https://hsiaopan.github.io/post-images/1590992683050.jpg" alt="" loading="lazy"></p>
<h2 id="数据可视化">数据可视化</h2>
<p>根据前面生成的数据透视表，可作出以下可视化图标：</p>
<ul>
<li>主要城市数据分析师需求情况<br>
<img src="https://hsiaopan.github.io/post-images/1590999009906.jpg" alt="" loading="lazy"></li>
<li>各城市数据分析师平均薪水情况<br>
<img src="https://hsiaopan.github.io/post-images/1590999036118.jpg" alt="" loading="lazy"></li>
<li>不同工作年限的平均薪水对比<br>
<img src="https://hsiaopan.github.io/post-images/1590999047688.jpg" alt="" loading="lazy"></li>
<li>深圳市不同工作年限数据分析师的平均薪水和需求对比<br>
<img src="https://hsiaopan.github.io/post-images/1590999064895.jpg" alt="" loading="lazy"></li>
</ul>
<h2 id="结论">结论</h2>
<ul>
<li>从需求情况可以看出，数据分析师的工作机会主要集中在一线城市，北京居首；新一线城市中也有一些机会，接近一线城市，如杭州7.17%与广州8.42%差距已不大</li>
<li>从各城市平均薪水表可以看到，该岗位在深圳的薪水最高，其次是北京、上海</li>
<li>随着经验累积，薪酬不断提升，3-5年工作经验的薪水已接近1-3年经验的两倍，10年以上经验的虽超过3倍，但该阶段需求很小，数据量小，难以反映真实情况</li>
<li>从深圳的数据分析师需求来看，因为职业较新，主要工作机会给予集中在1-5年有经验的人身上</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://hsiaopan.github.io/post/about/</id>
        <link href="https://hsiaopan.github.io/post/about/">
        </link>
        <updated>2019-05-01T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>本站主要作为我的个人成长记录，从开始写那一刻开始记录。</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>华中地区某普通211毕业的农学背景男。<br>
大学期间辅修过建筑学，未完成学业。<br>
研究生在某国内头部大学师从某行业国内领军人物，但因种种原因未完成学业。</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>没有固定兴趣爱好。可以打游戏，可以撸代码。</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>暂时不了。</p>
]]></content>
    </entry>
</feed>